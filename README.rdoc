= Servicy registry

The service registry provides:
* {decision support}[file:features/dss.feature] when mapping services
* {listing domain perspectives}[file:features/list_domain_perspectives.feature] when provisioning service components and mapping service components to domain perspectives
* {listing service components}[file:features/list_service_components.feature] when provisioning service components and mapping service components to domain perspectives
* {registering domain perspectives}[file:features/register_domain_perspective.feature] when new domain perspectives become relevant
* {registering service components}[file:features/register_service_component.feature] when new service components are added
* {deregistering service components}[file:features/deregister_service_component.feature] when service components should no longer be accessible
* {registering services with their definition}[file:features/register_service.feature] when associating services with service components
* {deregistering service components and their definitions}[file:features/deregister_service.feature] when service and service component associations should no longer be made
* {finding a list of services in domain perspectives}[file:features/service_search.feature] matching service search criteria
* {obtaining a service definition}[file:features/service_definition.feature] given a service identifier

The service registry and / or any clients may support:
* {querying service status}[file:features/service_status.feature] when deciding which service from a pool of candidate services are best to use

The service requires:
* {bootstrapping with a configuration service}[file:features/bootstrap_with_configuration_service.feature]
* {bootstrapping with a globally unique identifier}[file:features/bootstrap_identifier.feature]

The service supports:
* {configuration}[file:features/configuration.feature] of the registry.

The service registry depends on:
* {a directory configuration}[file:features/configure_with_directory.feature] for UDDI and inetOrgPerson support
* {discovery of domain perspectives}[file:features/discover_domain_perspectives.feature]
* {discovery of service components}[file:features/discover_service_components.feature] using a UDDI directory.

A pluggable Ruby API is provided in {ServiceRegistry::Base}.

The declarative specification of the service is implemented with cucumber, using pluggable imperative orchestration providers.
This allows for implementations that are not providers to the Ruby API.
See {ServiceRegistry::Test}.

A stub service provider is provided in {ServiceRegistry::Provider::Stub}.
This is used to validate the test framework architecture, and may be used as a stub configuration service in tests.
{https://rubygems.org/search?query=service_registry-provider Other providers} are available as gems.

Service providers are registered against the {ServiceRegistry::ProviderRegistry}.

Factories for creating and configuring service instances are provided in {ServiceRegistry::Factory}.

== Usage

The recommended approach to creating a service registry client is to use a Factory

For example, we can use the EnvironmentContext factory to create and configure
a configuration service client backed by the vault provider as below.

We could also use a ConfigurationContext factory to retrieve service registry details from a configuration service.

Our +main.rb+ is simple:

  require 'bundler'
  Bundler.require(:default)

  registry = ServiceRegistry::Factory::EnvironmentContext.create
  billing_scs, base_url = registry.find_service_component_by_domain_perspective("billing")

This relies on a bundler Gemfile to load the gem that contains whatever
service provider we configure in the environment:

  source 'https://rubygems.org'

  gem 'service_registry-provider-juddi'
  gem 'acme_application'

Now we use the process environment to configure the EnvironmentContext factory:

  SERVICE_REGISTRY_IDENTIFIER="acme" \
  SERVICE_REGISTRY_TOKEN="0b2a80f4-54ce-45f4-8267-f6558fee64af" \
  SERVICE_REGISTRY_PROVIDER="juddi" \
  SERVICE_REGISTRY_PROVIDER_ADDRESS="http://127.0.0.1:8009" \
  bundle exec main.rb

Note that +main.rb+ is completely decoupled from the selection of provider and
provider configuration. We could swap and/or reconfigure the provider by
manipulating only the Gemfile and the environment.




